# Starting the project

To begin run:

```
yarn bootstrap; yarn start;
```

`yarn bootstrap` installs all the packages into node_modules for all the sub-projects. It also links the test-app to package so changes to the package cause a reload of test-app

`yarn start` starts all the sub-projects. Webpack will listen for changes and rebuild the relevant distributions as changes are made.

# Project Structure

The structure of the project is fairly complex due to the requirements. The way the package works is that it contains a relatively small amount of code that the developer interacts with directly (for example graph.add() or appendIcon()). But it also contains all the code to build the UI within the new window (the actual dev-tools). This code is represented as a massive string in package/core/src/injection.ts, and it actually written to the new window's document. This string is generated by a process within package/core/create-injector-file.

Furthermore that giant string contains several web-workers which themselves are represented as giant strings. These web-workers are needed because some things are computationally expensive and need to be done in a separate thread. The two web workers are package/graph-render-web-worker and package/search-web-worker.

## test-app

test-app is a basic create-react-app project using typescript that is used to test and debug the package. It is connected to the package via `yarn link` so that changes to package trigger an immediate rebuild.

## package/core

This is the actual code that gets installed into the developer's project. Specifically, package/core/redux-visualize-dist is the distribution installed into the developer's project. The starting point of the source code of the package is package/core/src/index.ts.

## package/injected-code

This is where most of the code for the project lives. It is a redux application for the actual UI of the dev-tools. After every change to the source code, webpack builds the distribution into package/core/injected-code-dist.

## package/core/create-injector-file

This is a simple node process that listens for changes to package/core/injected-code-dist and converts the javascript code into a giant string and puts it into package/core/src/injection.ts

## package/core/graph-render-web-worker

Calculating the appearance of the dependency graph can sometimes be very computationally expensive. So this code is put inside a web worker. The compiled code is put into package/injected-code/src/gen-graph-layout/worker.txt.js

## package/core/search-web-worker

Search in the dev-tools is done by finding subsrings within two potentially long strings. This code can take a long time, so it is put inside a web worker. The compiled code is put into package/injected-code/src/search/core/worker.txt.js.

# Functionality

- Viewing state, actions, and actions' effect on state. This will work even for large states because it doesn't rely on serialization.
- Time travel debugging
- Viewing the dependency graph of the application. This includes state variables, selectors, connected components, functions, and unconnected react components.
- Identifying performance issues. Every function call records the time it took to compute. Also you can only show nodes which were called in the last action to identify over-rendering.
- Finding code. You can copy/paste a block of code into the search bar. Then view all the dependencies/dependents of that block of code.
- Viewing components in an isolated environment. You can view the live react component within the dev-tools
